<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces Round #620 (Div. 2)]]></title>
    <url>%2F2020%2F03%2F15%2FCodeforces-Round-620-Div-2%2F</url>
    <content type="text"><![CDATA[这场是棒子场，感觉比较水，很多人 AK…… 但是我比较菜，比赛的时候 F 没想到可以维护前缀和后缀，然后就放弃了。 不管怎么说，还是上分了。 A小学奥数题：相遇问题 显然，两只兔兔相遇所需要的时间为 \frac{y - x}{a + b}。但在此题中答案只可能是整数时间，所以如果不能整除，就输出 -1。 12345678910111213141516#include &lt;cstdio&gt;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; int x, y, a, b; scanf("%d%d%d%d", &amp;x, &amp;y, &amp;a, &amp;b); if ((y - x) % (a + b)) &#123; puts("-1"); continue; &#125; printf("%d\n", (y - x) / (a + b)); &#125; return 0;&#125; B所有字符串的长度是一样的，这意味着，我们要将互为回文（两者可以通过互相翻转得到）的字符串两两配对。 最终的字符串中间还可以插入一个本身回文的字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;int n, m, cnt1, cnt2;char a[105][55];int vis[105];int ans1[55], ans2[55];int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf("%s", a[i]); for (int i = 2; i &lt;= n; ++i) for (int j = 1; j &lt; i; ++j) // 两两配对 if (!vis[i] &amp;&amp; !vis[j]) &#123; // 字符串不能重复用喔 int fail = 0; for (int k = 0; k &lt; m; ++k) if (a[i][k] != a[j][m - k - 1]) &#123; fail = 1; break; &#125; if (fail) continue; ans1[++cnt1] = i; // 插入在前面 ans2[++cnt2] = j; // 插入在后面 vis[i] = 1; vis[j] = 1; &#125; for (int i = 1; i &lt;= n; ++i) // 插入本身回文的字符串 if (!vis[i]) &#123; int fail = 0; for (int j = 0; j &lt; m; ++j) if (a[i][j] != a[i][m - j - 1]) &#123; fail = 1; break; &#125; if (fail) continue; ans1[++cnt1] = i; break; &#125; printf("%d\n", (cnt1 + cnt2) * m); for (int i = 1; i &lt;= cnt1; ++i) printf("%s", a[ans1[i]]); for (int i = cnt2; i; --i) printf("%s", a[ans2[i]]); puts(""); return 0;&#125; C观察到此题 l_i, r_i 范围很大，自然不可能是 DP。 我们考虑对于每个顾客来时确定可能的 l, r 边界。 显然，每过 t min，l -= t, r += t。 如果这个范围不在 l_i, r_i 内，则顾客的要求无法满足，输出 NO。 否则，根据 l_i, r_i 调整 l, r 然后继续。 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define N 105struct node &#123; int t, l, r;&#125; a[N];inline bool cmp(const node &amp;x, const node &amp;y) &#123; return x.t &lt; y.t; &#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf("%d%d%d", &amp;a[i].t, &amp;a[i].l, &amp;a[i].r); std::sort(a + 1, a + n + 1, cmp); // 先根据时间排序 int l = m, r = m; int fail = 0; for (int i = 1; i &lt;= n; ++i) &#123; l -= a[i].t - a[i - 1].t, r += a[i].t - a[i - 1].t; // 更新边界 if (l &gt; a[i].r || r &lt; a[i].l) &#123; fail = 1; break; &#125; l = std::max(l, a[i].l); // 调整边界 r = std::min(r, a[i].r); &#125; if (fail) puts("NO"); else puts("YES"); &#125; return 0;&#125; D为了使 LIS 最短，我们需要让数据整体呈下降趋势。 那么，我们肯定要让连续上升的子段上升的尽量少（也就是连续），总体下降就行。 同理，要使 LIS 最长，就让连续下降的子段连续，总体上升即可。 具体还是看实现清楚。 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;char s[200005];int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; int n; scanf("%d", &amp;n); scanf("%s", s); int sum = 0, ans = n; for (int i = 0; i &lt; n; ++i) if (s[i] == '&lt;') ++sum; // 统计连续上升的子段 else &#123; for (int j = ans - sum; j &lt;= ans; ++j) printf("%d ", j); // 输出该连续子段（包括单独的一点） ans -= sum + 1; sum = 0; &#125; if (ans &gt; sum) for (int i = ans - sum; i &lt;= ans; ++i) printf("%d ", i); puts(""); sum = 0, ans = 1; for (int i = 0; i &lt; n; ++i) if (s[i] == '&gt;') ++sum; // 统计连续下降的子段 else &#123; for (int j = ans + sum; j &gt;= ans; --j) printf("%d ", j); ans += sum + 1; sum = 0; &#125; if (ans + sum &lt;= n) for (int i = ans + sum; i &gt;= ans; --i) printf("%d ", i); puts(""); &#125; return 0;&#125; E判断一条长度为 k 的路径是否存在，我们可以对于 k 为奇、偶的情况分别判断是否大于最短路。 原理很简单，因为我们可以在路径中的一条边来回走，所以分奇偶情况判断即可。 此题比较特殊：原图是一棵树，并且加边操作相互独立，我们可以直接用 LCA 求唯一的路径长度。 加边之后我们有两种路径：一种从原来的树上走，一种从新边走。 剩下的就是基本操作了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define N 100005int n, q;int d[N], lg[N], f[N][25];std::vector&lt;int&gt; v[N];void dfs(int x, int fa) &#123; f[x][0] = fa; d[x] = d[fa] + 1; for (int i = 1; i &lt;= lg[d[x]]; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; for (int i : v[x]) if (i != fa) dfs(i, x);&#125;inline int lca(int x, int y) &#123; if (d[x] &lt; d[y]) std::swap(x, y); while (d[x] &gt; d[y]) x = f[x][lg[d[x] - d[y]]]; if (x == y) return x; for (int i = lg[d[x]]; ~i; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0];&#125;inline int dis(int x, int y) &#123; return d[x] + d[y] - (d[lca(x, y)] &lt;&lt; 1);&#125;/* 以上为 LCA 基本操作 */int main() &#123; scanf("%d", &amp;n); for (int i = 1, x, y; i &lt; n; ++i) &#123; scanf("%d%d", &amp;x, &amp;y); v[x].push_back(y); v[y].push_back(x); &#125; for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i &gt;&gt; 1] + 1; dfs(1, 0); scanf("%d", &amp;q); for (int i = 0, x, y, a, b, k, Dis; i &lt; q; ++i) &#123; scanf("%d%d%d%d%d", &amp;x, &amp;y, &amp;a, &amp;b, &amp;k); Dis = dis(a, b); if (Dis &lt;= k &amp;&amp; (Dis &amp; 1) == (k &amp; 1)) &#123; puts("YES"); continue; &#125; Dis = std::min(dis(a, x) + dis(b, y) + 1, dis(a, y) + dis(b, x) + 1); // 容易错的地方，注意两种可能中只有一种是较小的 if (Dis &lt;= k &amp;&amp; (Dis &amp; 1) == (k &amp; 1)) &#123; puts("YES"); continue; &#125; puts("NO"); &#125; return 0;&#125; F1设 f_{i, j} 是第 i 天在 j 个位置放置的最大值。 设 sum_{i, j} 是第 i 行的前缀和。 通过 sum_{i, j} 我们先可以求出 f_{1, j}。 根据题意不难写出递推的式子： f_{i, j} = sum_{i + 1, j + k - 1} - sum_{i + 1, j - 1} + \text{max} \begin {cases} f_{i - 1, l} + sum_{i, j + k - 1} - sum_{i, j - 1} & (1 \leq l \leq j - k) \\ f_{i - 1, l} + sum_{i, j + k - 1} - sum_{i, l + k - 1} & (j - k + 1 \leq l \leq j) \\ f_{i - 1, l} + sum_{i, l - 1} - sum_{i, j - 1} & (j + 1 \leq l \leq j + k - 1) \\ f_{i - 1, l} + sum_{i, j + k - 1} - sum_{i, j - 1} & (j + k \leq l \leq m - k + 1) \\ \end {cases}直接转移是 O(n m ^ 2) 的，不过我们观察到当 1 \leq l \leq j - k 时，\text{max} \{ f_{i - 1, l} + sum_{i, j + k - 1} - sum_{i, j - 1} \} 仅与 f_{i - 1, l} 有关，因此我们可以用一个前缀 \text{max} 维护。当 j + k \leq l \leq m - k + 1 时同理可以维护后缀 \text{max}。 观察到 k 很小，当 j - k + 1 \leq l \leq j + k - 1 时我们可以暴力转移。总时间复杂度是 O(n m k) 的。 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define N 55#define M 20005int n, m, k;int a[N][M], sum[N][M], f[N][M], pre[M], suf[M];int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; scanf("%d", &amp;a[i][j]); sum[i][j] = sum[i][j - 1] + a[i][j]; &#125; for (int i = 1; i &lt;= m - k + 1; ++i) f[1][i] = sum[1][i + k - 1] - sum[1][i - 1] + sum[2][i + k - 1] - sum[2][i - 1]; for (int i = m - k + 1; i; --i) suf[i] = std::max(suf[i + 1], f[1][i]); for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m - k + 1; ++j) pre[j] = std::max(pre[j - 1], f[i - 1][j]); // 维护前缀后缀 for (int j = m - k + 1; j; --j) suf[j] = std::max(suf[j + 1], f[i - 1][j]); for (int j = 1; j &lt;= m - k + 1; ++j) &#123; f[i][j] = std::max(j &gt; k ? pre[j - k] : 0, j + k &lt;= m - k + 1 ? suf[j + k] : 0) + sum[i][j + k - 1] - sum[i][j - 1]; for (int l = std::max(1, j - k + 1); l &lt;= j; ++l) f[i][j] = std::max(f[i][j], f[i - 1][l] + sum[i][j + k - 1] - sum[i][l + k - 1]); if (j &lt;= m - k) for (int l = j + 1; l &lt;= j + k - 1 &amp;&amp; l &lt;= m - k + 1; ++l) f[i][j] = std::max(f[i][j], f[i - 1][l] + sum[i][l - 1] - sum[i][j - 1]); f[i][j] += sum[i + 1][j + k - 1] - sum[i + 1][j - 1]; &#125; &#125; int ans = 0; for (int i = 1; i &lt;= m - k + 1; ++i) ans = std::max(ans, f[n][i]); printf("%d\n", ans);&#125; F2Hard version k 的范围变大了，说明在 j - k + 1 \leq l \leq j + k - 1 情况下的转移还可以继续优化。 当 j - k + 1 \leq l \leq j 时，\text{max} \{ f_{i - 1, l} + sum_{i, j + k - 1} - sum_{i, l + k - 1} \} 仅与 f_{i - 1, l} - sum_{i, l + k - 1} 有关。再观察可得 l 的范围是滑动的。因此我们可以用单调队列来维护这个值。当 j + 1 \leq l \leq j + k - 1 时同理。 时间复杂度 O(n m)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;deque&gt;#include &lt;algorithm&gt;#include &lt;utility&gt;#define N 55#define M 20005int n, m, k;int a[N][M], sum[N][M], f[N][M], pre[M], suf[M];std::deque&lt;std::pair&lt;int, int&gt; &gt; q1, q2;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; scanf("%d", &amp;a[i][j]); sum[i][j] = sum[i][j - 1] + a[i][j]; &#125; for (int i = 1; i &lt;= m - k + 1; ++i) f[1][i] = sum[1][i + k - 1] - sum[1][i - 1] + sum[2][i + k - 1] - sum[2][i - 1]; for (int i = m - k + 1; i; --i) suf[i] = std::max(suf[i + 1], f[1][i]); for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m - k + 1; ++j) pre[j] = std::max(pre[j - 1], f[i - 1][j]); for (int j = m - k + 1; j; --j) suf[j] = std::max(suf[j + 1], f[i - 1][j]); q1.clear(), q2.clear(); for (int j = 1; j &lt;= std::min(k - 1, m - k + 1); ++j) &#123; while (!q2.empty() &amp;&amp; f[i - 1][j] + sum[i][j - 1] &gt;= q2.back().second) q2.pop_back(); q2.push_back(std::make_pair(j, f[i - 1][j] + sum[i][j - 1])); &#125; for (int j = 1; j &lt;= m - k + 1; ++j) &#123; f[i][j] = std::max(j &gt; k ? pre[j - k] : 0, j + k &lt;= m - k + 1 ? suf[j + k] : 0) + sum[i][j + k - 1] - sum[i][j - 1]; while (!q1.empty() &amp;&amp; f[i - 1][j] - sum[i][j + k - 1] &gt;= q1.back().second) q1.pop_back(); q1.push_back(std::make_pair(j, f[i - 1][j] - sum[i][j + k - 1])); while (!q1.empty() &amp;&amp; q1.front().first &lt;= j - k) q1.pop_front(); f[i][j] = std::max(f[i][j], q1.front().second + sum[i][j + k - 1]); if (j + k - 1 &lt;= m - k + 1) &#123; while (!q2.empty() &amp;&amp; f[i - 1][j + k - 1] + sum[i][j + k - 2] &gt;= q2.back().second) q2.pop_back(); q2.push_back(std::make_pair(j + k - 1, f[i - 1][j + k - 1] + sum[i][j + k - 2])); &#125; while (!q2.empty() &amp;&amp; q2.front().first &lt;= j) q2.pop_front(); if (!q2.empty()) f[i][j] = std::max(f[i][j], q2.front().second - sum[i][j - 1]); f[i][j] += sum[i + 1][j + k - 1] - sum[i + 1][j - 1]; &#125; &#125; int ans = 0; for (int i = 1; i &lt;= m - k + 1; ++i) ans = std::max(ans, f[n][i]); printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>Codeforces Round Div. 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018普及组游记]]></title>
    <url>%2F2020%2F03%2F08%2FNOIP2018%2F</url>
    <content type="text"><![CDATA[为了纪念 NOIP 它又活了，搬运了以前写的游记（雾 Day -27NOIP初赛。 因为这次初赛的举办地点在余姚中学，所以就自己回家了。 但是不幸的是，在早上，莫名其妙的眼镜被别人打碎了。 那只能去配了。不然考试怎么办。 急忙回家，准备上高速。发现取卡机坏了，没卡…… 等了5min，工作人员来取卡了。一直按啊按，还是取不出来（因为根本没卡）。 又过了5min，工作人员突然意识到没卡的问题，才去拿了一张卡来。 于是等了10min，总算上了高速，回家。 到家之后，找到病历本直接去配眼镜。等了15min。 中午随便吃了一点。 到余姚中学，先和老师同学们都打了招呼。 进入考场，开始啥也没干，静等试卷发下。 后来发现同班的巨佬FSQ跟我同一个考场，便愉快的和他聊了起来。 发试卷了。 看到选择题，感觉非常可怕。 一道拼RP题（就是第5题），显然要错。 然后查找啊，排列组合啊感觉很难，就都算错了。过于紧张。 问题求解不难。非常开心。我主要丢分的地方 阅读程序除T3外都不难，不过我也有时间做T3。 但是：把T3函数里的-看成了+，然后模拟的时候运算量特别大，重点是错了…… 我还算了好几遍 所以-8pts。 完善程序T1显然。T2第一眼看到懵逼。 然后做一个复读机，又暴力模拟了几次程序，竟然做对了。 最终分数86。 Day -26~-20焦急等待分数线。 在此之间一直听说ZJ的分数线高达90，所以非常害怕凉凉。那就要AFO了。 还好后来出来不到80。 Day -19~-8因为要期中考试，所以要拼命肝文化课。 然而一点兴趣也没有，还是忙于搞OI。 每天在晚读前偷偷溜去机房玩一会 Day -7~-6马上要期中考试了。 但我并不想复习。 在家里自学算法。 Day -5~-4期中考试Day 1~2。 果然凉凉了。 Day -3~-1停课搞OI了…… 老师把往年的NOIP真题都拿出来给我们当膜你赛了，然后次次rank -1。 没关系反正是攒rp Day 0上午又是膜你赛。总算开心的到了rank 1。 中午随便吃了点东西，去小卖部买了许多薯片、其他零食以及肥宅快乐水，就出发去杭州了。 到学军又是打招呼，然后吃晚饭，去旅馆。 一整晚没睡觉，一直在嗨皮。 我们大多数人都去了两间相连的房间，中途我还去旅馆大堂的小卖部买了点零食以及方便面。（到午夜关门） Day 1早上还在嗨皮，但是大家都开始看电视了。 凌晨2点的时候很多人都睡觉了，所以我就回了自己的房间看电视。 3点时觉得很困，喝了杯咖啡，奇迹般的睡着了。 早上起来去吃自助餐，种类很少，不过吃起来不错。 上午就呆在休息室里，没事情好干，玩了一上午的天黑请闭眼。 吃了中饭，买了瓶咖啡进考场，准备考试。 现场监考老师说不要动电脑，但我处于个人习惯，还是在D盘新建了个文件夹，然后重启。 惊喜：我这电脑装了5个系统！（包括Windows和Ubuntu） 看来我不怕什么程序不兼容的问题了（不过Pascal本来就没什么兼容问题嘛）。 看了看提供的安装包，有fp dev-cpp vim emacs和sublime。然而个人习惯用npp…… 随机装了个sublime。fp是必装的。 考场里为了安全，我直接用sublime写代码，脚本编译并比对文件。 事实上fpc的默认编译选项是不带错误检查的，考场上没注意到这一点，导致程序溢出了好几次。不过大样例一测看输出结果是负数就知道错了。 等了10min，密码下发了。是改革开放40年。 解密，解压，看题。 T1标题统计，zz题目，跟去年一样。肯定不会错。20s搞定。 T2龙虎斗，我非常注意，因为每次膜你赛我T2都会错。 果然，看了看数据范围，要开int64/long long！ 不过按照我的惯例，我只开一个int64/long long的变量，然后其他靠强制类型转换。 不过这样做很冒险 这道题目第一想法是计算龙虎势力的差距，就是正负加权和啊。 然后每个点都枚举一遍，比较加权和的绝对值就好了。花了15min。 T3太坑了……不过显然DP。 我用我的玄学大法，写了个显然不对的O(n^2)DP。 具体我也忘记怎么写了。 然后花了3h，给DP进行各种玄学优化，最后跟大样例只差一点点了。 后来公布程序以后我发现我的程序应对各种随机数据特别好，特别开心。 可是被CCF最后卡到只有30pts……OI赛制没办法。 最后距离比赛结束只有15min了。只好去看T4。 第一预感是某些从底部向上合并的东西，还有就是hash玄学拿分。 但是似乎来不及了，只好打爆搜。 非常好打，5min打完。一测大样例：0.3s。感觉会被卡。结果CCF用了新机子…… 最后检查了一下文件就静等考试结束了。 走出考场，同学们的个人感觉都是要凉，250pts差不多了。 吃完晚饭，就回学校了。 Day 2~9等待分数。 自测很好，375pts。洛谷上360pts。 Day 10CCF果然又咕了。 Day 11没想到ZJ还是挺快的，只拖了一天。 被CCF定向卡到了330。 反正一等有了。 不等分数线了。 后续：滚回文化课。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>NOIP</tag>
        <tag>NOIP普及组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2020%2F03%2F08%2Ftest%2F</url>
    <content type="text"><![CDATA[Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! 1Hello, world! 123456#include &lt;cstdio&gt;int main() &#123; puts("Hello, world!"); return 0;&#125; \text{Hello, world!} \text{Hello, world!} quote quote quote Hello World hello world hello world hello world \text{Hello, world!} \text{Hello, world!}]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
